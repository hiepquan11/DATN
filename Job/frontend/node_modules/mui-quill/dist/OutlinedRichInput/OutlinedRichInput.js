"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var jsx_runtime_1 = require("react/jsx-runtime");
var NotchedOutline_1 = __importDefault(require("@material-ui/core/OutlinedInput/NotchedOutline"));
var styles_1 = require("@material-ui/core/styles");
var clsx_1 = __importDefault(require("clsx"));
var react_1 = require("react");
var RichInputBase_1 = __importDefault(require("../RichInputBase"));
/**
 * Styles
 */
var stylesInjector = styles_1.withStyles(function (theme) {
    var light = theme.palette.type === 'light';
    var borderColor = light ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
    return styles_1.createStyles({
        /* Styles applied to the root element. */
        root: {
            position: 'relative',
            borderRadius: theme.shape.borderRadius,
            '&:hover $notchedOutline': {
                borderColor: theme.palette.text.primary,
            },
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
                '&:hover $notchedOutline': {
                    borderColor: borderColor,
                },
            },
            '&$focused $notchedOutline': {
                borderColor: theme.palette.primary.main,
                borderWidth: 2,
            },
            '&$error $notchedOutline': {
                borderColor: theme.palette.error.main,
            },
            '&$disabled $notchedOutline': {
                borderColor: theme.palette.action.disabled,
            },
        },
        /* Styles applied to the root element if the color is secondary. */
        colorSecondary: {
            '&$focused $notchedOutline': {
                borderColor: theme.palette.secondary.main,
            },
        },
        /* Styles applied to the root element if the component is focused. */
        focused: {},
        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},
        /* Styles applied to the root element if `startAdornment` is provided. */
        adornedStart: {
            paddingLeft: 14,
        },
        /* Styles applied to the root element if `endAdornment` is provided. */
        adornedEnd: {
            paddingRight: 14,
        },
        /* Pseudo-class applied to the root element if `error={true}`. */
        error: {},
        /* Styles applied to the `input` element if `size="small"`. */
        sizeSmall: {},
        /* Styles applied to the `NotchedOutline` element. */
        notchedOutline: {
            borderColor: borderColor,
        },
        /* Styles applied to the `input` element. */
        input: {
            padding: '16.5px 14px',
        },
        /* Styles applied to the `input` element if `size="small"`. */
        inputSizeSmall: {
            paddingTop: 8.5,
            paddingBottom: 8.5,
        },
        /* Styles applied to the `input` element if `startAdornment` is provided. */
        inputAdornedStart: {
            paddingLeft: 0,
        },
        /* Styles applied to the `input` element if `endAdornment` is provided. */
        inputAdornedEnd: {
            paddingRight: 0,
        },
        /* Styles applied to the root element if the component is a descendant of `FormControl`. */
        formControl: {},
        /* Styles applied to the root element if `fullWidth={true}`. */
        fullWidth: {},
        /* Styles applied to the `input` element if `margin="dense"`. */
        marginDense: {},
        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {},
        /* Styles applied to the root element if `hiddenLabel={true}`. */
        hiddenLabel: {},
        /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */
        inputHiddenLabel: {
            paddingTop: 16,
            paddingBottom: 17,
            '&$inputMarginDense': {
                paddingTop: 8,
                paddingBottom: 9,
            },
        },
    });
}, { name: 'OutlinedRichInput' });
/**
 * Outlined Rich Input
 *
 * @param {OutlinedRichInputProps} props
 * @returns {JSX.Element}
 */
var OutlinedRichInput = react_1.forwardRef(function OutlinedRichInput(props, ref) {
    var classes = props.classes, label = props.label, notched = props.notched, other = __rest(props, ["classes", "label", "notched"]);
    // Render
    return (jsx_runtime_1.jsx(RichInputBase_1.default, __assign({ renderSuffix: function (state) { return (jsx_runtime_1.jsx(NotchedOutline_1.default, { className: classes.notchedOutline, label: label, labelWidth: 0, notched: typeof notched !== 'undefined'
                ? notched
                : Boolean(state.startAdornment || state.filled || state.focused) }, void 0)); }, classes: __assign(__assign({}, classes), { root: clsx_1.default(classes.root) }), ref: ref }, other), void 0));
});
// DEFAULT EXPORT
exports.default = stylesInjector(OutlinedRichInput);
//# sourceMappingURL=OutlinedRichInput.js.map