"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stylesInjector = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var FormControl_1 = require("@material-ui/core/FormControl");
var styles_1 = require("@material-ui/core/styles");
var react_1 = require("react");
var quill_1 = __importDefault(require("quill"));
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var clsx_1 = __importDefault(require("clsx"));
var isEqual_1 = __importDefault(require("lodash/isEqual"));
var RichInputToolbar_1 = __importDefault(require("../RichInputToolbar"));
var postpone_1 = __importDefault(require("../utils/postpone"));
var useEnhancedEffect_1 = __importDefault(require("../utils/useEnhancedEffect"));
var quill_2 = __importDefault(require("./styles/quill"));
var formControlStates = [
    'color',
    'disabled',
    'error',
    'hiddenLabel',
    'margin',
    'required',
    'filled',
];
/**
 * Form Control State
 *
 * @param {Record<string,any>} props
 * @param {Record<string,any>|undefined} formControl
 * @returns {Record<string,any>}
 */
function formControlState(props, formControl) {
    return formControlStates.reduce(function (acc, state) {
        acc[state] = props[state];
        if (formControl) {
            if (typeof props[state] === 'undefined') {
                acc[state] = formControl[state];
            }
        }
        return acc;
    }, {});
}
/**
 * Supports determination of isControlled().
 * Controlled input accepts its current value as a prop.
 *
 * @see https://facebook.github.io/react/docs/forms.html#controlled-components
 * @param value
 * @returns {boolean} true if string (including '') or number (including zero)
 */
function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
}
/**
 * Check if the givven value is a valid delta.
 *
 * @param {any} value
 */
function isDelta(value) {
    return value && value.ops;
}
/**
 * Determine if field is empty or filled.
 * Response determines if label is presented above field or as placeholder.
 *
 * @param obj
 * @param SSR
 * @returns {boolean} False when not present or empty string.
 *                    True when any number or string with length.
 */
function isFilled(obj, SSR) {
    if (SSR === void 0) { SSR = false; }
    return (obj &&
        ((hasValue(obj.value) && obj.value !== '') ||
            (SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '')));
}
/**
 * Special comparison function that knows how to compare Deltas.
 */
function isEqualValue(value, nextValue) {
    if (isDelta(value) && isDelta(nextValue)) {
        return isEqual_1.default(value.ops, nextValue.ops);
    }
    else {
        return isEqual_1.default(value, nextValue);
    }
}
/**
 * Styles
 */
exports.stylesInjector = styles_1.withStyles(function (theme) {
    return styles_1.createStyles({
        /* Styles applied to the root element. */
        root: __assign(__assign({}, theme.typography.body1), { color: theme.palette.text.primary, lineHeight: '1.4375em', boxSizing: 'border-box', position: 'relative', cursor: 'text', display: 'flex', flexDirection: 'column', alignItems: 'center', '&$disabled': {
                color: theme.palette.text.disabled,
                cursor: 'default',
            } }),
        /* Styles applied to the root element if the component is a descendant of `FormControl`. */
        formControl: {},
        /* Styles applied to the root element if the component is focused. */
        focused: {},
        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},
        /* Styles applied to the root element if `startAdornment` is provided. */
        adornedStart: {},
        /* Styles applied to the root element if `endAdornment` is provided. */
        adornedEnd: {},
        /* Pseudo-class applied to the root element if `error={true}`. */
        error: {},
        /* Styles applied to the `input` element if `margin="dense"`. */
        marginDense: {},
        /* Styles applied to the root element if the color is secondary. */
        colorSecondary: {},
        /* Styles applied to the root element if `fullWidth={true}`. */
        fullWidth: {
            width: '100%',
        },
        /* Styles applied to the root element if `hiddenLabel={true}`. */
        hiddenLabel: {},
        /* Styles applied to the `input` element. */
        input: {
            font: 'inherit',
            letterSpacing: 'inherit',
            color: 'currentColor',
            padding: '4px 0 5px',
            border: 0,
            boxSizing: 'border-box',
            background: 'none',
            margin: 0,
            display: 'block',
            // Make the flex item shrink with Firefox
            minWidth: 0,
            width: '100%',
            '&:focus': {
                outline: 0,
            },
            // Reset Firefox invalid required input style
            '&:invalid': {
                boxShadow: 'none',
            },
            '&$disabled': {
                opacity: 1,
            },
        },
        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {
            paddingTop: 1,
        },
        /* Styles applied to the `input` element if `startAdornment` is provided. */
        inputAdornedStart: {},
        /* Styles applied to the `input` element if `endAdornment` is provided. */
        inputAdornedEnd: {},
        /* Styles applied to the `input` element if `hiddenLabel={true}`. */
        inputHiddenLabel: {},
    });
}, { name: 'RichInputBase' });
/**
 * Rich Input Base
 *
 * @param {RichInputBaseProps} props
 * @returns {JSX.Element}
 */
var RichInputBase = react_1.forwardRef(function RichInputBase(props, ref) {
    var _a, _b;
    var placeholder = props.placeholder, fullWidth = props.fullWidth, error = props.error, disabled = props.disabled, value = props.value, classes = props.classes, _c = props.options, options = _c === void 0 ? { toolbar: false } : _c, renderSuffix = props.renderSuffix, onChange = props.onChange;
    // Quill Style Sheet
    quill_2.default();
    // Form Control
    var _d = react_1.useState(false), focused = _d[0], setFocused = _d[1];
    var formControl = FormControl_1.useFormControl();
    var fcs = formControlState(props, formControl);
    fcs.focused = formControl ? formControl.focused : focused;
    var onFilled = formControl && formControl.onFilled;
    var onEmpty = formControl && formControl.onEmpty;
    /**
     * Handle Focus
     */
    var handleFocus = react_1.useCallback(function () {
        if (formControl && formControl.onFocus) {
            formControl.onFocus();
        }
        else {
            setFocused(true);
        }
    }, [formControl]);
    /**
     * Handle Blur
     */
    var handleBlur = react_1.useCallback(function () {
        if (formControl && formControl.onBlur) {
            formControl.onBlur();
        }
        else {
            setFocused(false);
        }
    }, [formControl]);
    // Editor instance reference
    var editorRef = react_1.useRef();
    // Latest Selection
    var selectionRef = react_1.useRef();
    // Latest Contents
    var contentsRef = react_1.useRef();
    // Latest Delta
    var lastDeltaChangeSetRef = react_1.useRef();
    // Is Controlled
    var isControlled = react_1.useRef(value != null).current;
    // Editor root reference
    var editorElementRef = react_1.useRef(null);
    // Editor toolbar reference
    var toolbarElementRef = react_1.useRef(null);
    /**
     * Set Editor Selection
     */
    var setEditorSelection = react_1.useCallback(function (editor, range) {
        selectionRef.current = range;
        if (range) {
            // Validate bounds before applying.
            var length_1 = editor.getLength();
            range.index = Math.max(0, Math.min(range.index, length_1 - 1));
            range.length = Math.max(0, Math.min(range.length, length_1 - 1 - range.index));
            editor.setSelection(range);
        }
    }, []);
    /**
     * Replace the contents of the editor, but keep the previous selection hanging
     * around so that the cursor won't move.
     */
    var setEditorContents = react_1.useCallback(function (editor, value) {
        contentsRef.current = value;
        var currentSelection = selectionRef.current;
        if (typeof value === 'string') {
            editor.setContents(editor.clipboard.convert(value));
        }
        else {
            editor.setContents(value);
        }
        postpone_1.default(function () {
            if (currentSelection) {
                setEditorSelection(editor, currentSelection);
            }
        });
    }, [setEditorSelection]);
    /**
     * Handle Click
     */
    var handleClick = react_1.useCallback(function () {
        if (editorRef.current) {
            console.log('hi');
            editorRef.current.focus();
        }
    }, []);
    /**
     * Check Dirty
     */
    var checkDirty = react_1.useCallback(function (obj) {
        if (isFilled(obj) || placeholder) {
            if (onFilled) {
                onFilled();
            }
        }
        else if (onEmpty) {
            onEmpty();
        }
    }, [onFilled, onEmpty, placeholder]);
    useEnhancedEffect_1.default(function () {
        if (isControlled) {
            checkDirty({ value: value });
        }
    }, [value, checkDirty, isControlled]);
    /**
     * Handle Change
     */
    var handleChange = react_1.useCallback(function (value) {
        if (!isControlled) {
            checkDirty({
                value: value,
            });
        }
        if (onChange) {
            onChange(value);
        }
    }, [checkDirty, isControlled, onChange]);
    /**
     * Handle Editor Text Change
     *
     * @param {Delta} delta
     * @param {Sources} sources
     * @param {Quill} editor
     */
    var handleEditorTextChange = react_1.useCallback(function (delta, __, editor) {
        var value = editor.getLength() === 1 ? '' : editor.root.innerHTML;
        // We keep storing the same type of value as what the user gives us,
        // so that value comparisons will be more stable and predictable.
        var nextContents = isDelta(value) ? editor.getContents() : value;
        if (nextContents !== contentsRef.current) {
            // Taint this `delta` object, so we can recognize whether the user
            // is trying to send it back as `value`, preventing a likely loop.
            lastDeltaChangeSetRef.current = delta;
            contentsRef.current = nextContents;
            handleChange(value);
        }
    }, [handleChange]);
    /**
     * Handle Editor Selection Change
     *
     * @param {Range} nextSelection
     * @param {Sources} sources
     * @param {Quill} editor
     */
    var handleEditorSelectionChange = react_1.useCallback(function (nextSelection, __, editor) {
        console.log('Here');
        var currentSelection = selectionRef.current;
        var hasGainedFocus = !currentSelection && nextSelection;
        var hasLostFocus = currentSelection && !nextSelection;
        if (isEqual_1.default(nextSelection, currentSelection)) {
            return;
        }
        selectionRef.current = nextSelection;
        if (hasGainedFocus) {
            handleFocus();
        }
        else if (hasLostFocus) {
            handleBlur();
        }
    }, [handleFocus, handleBlur]);
    /**
     * Handle Editor Change
     *
     * @param {'text-change'|'selection-change'} eventName
     * @param {Range|Delta} rangeOrDelta
     * @param {Range|Delta} prevRangeOrDelta
     * @param {Sources} sources
     */
    var handleEditorChange = react_1.useCallback(function (eventName, rangeOrDelta, ___, sources) {
        tiny_invariant_1.default(editorRef.current, 'No editor initiated to hook.');
        if (eventName === 'text-change') {
            handleEditorTextChange(rangeOrDelta, sources, editorRef.current);
        }
        else if (eventName === 'selection-change') {
            handleEditorSelectionChange(rangeOrDelta, sources, editorRef.current);
        }
    }, [editorRef, handleEditorTextChange, handleEditorSelectionChange]);
    /**
     * Initiate Editor
     */
    var initiateEditor = react_1.useCallback(function () {
        tiny_invariant_1.default(editorElementRef.current !== null, 'No element provided to initiate editor on top of it.');
        tiny_invariant_1.default(options.toolbar || toolbarElementRef !== null, 'No element provided to insert editor toolbar in it.');
        var instance = new quill_1.default(editorElementRef.current, {
            placeholder: placeholder,
            readOnly: disabled,
            formats: ['bold', 'italic', 'underline', 'list', 'blockquote', 'direction', 'align'],
            modules: __assign({}, (options.toolbar
                ? {
                    toolbar: {
                        container: toolbarElementRef.current,
                    },
                }
                : {})),
        });
        if (value !== undefined) {
            setEditorContents(instance, value);
        }
        // Hook Editor
        instance.on('editor-change', handleEditorChange);
        editorRef.current = instance;
        return function () {
            instance.off('editor-change', handleEditorChange);
        };
    }, [placeholder, disabled, value, options, setEditorContents, handleEditorChange]);
    // Disable/Enable Editor
    react_1.useEffect(function () {
        if (editorRef.current) {
            if (disabled) {
                editorRef.current.disable();
            }
            else {
                editorRef.current.enable();
            }
        }
    }, [disabled]);
    // Change Value
    react_1.useEffect(function () {
        if (editorRef.current) {
            var prevContents = contentsRef.current;
            var nextContents = value !== null && value !== void 0 ? value : '';
            if (!isEqualValue(nextContents, prevContents)) {
                setEditorContents(editorRef.current, nextContents);
            }
        }
    }, [value, setEditorContents]);
    // Initiate Editor
    react_1.useEffect(function () {
        if (!editorRef.current) {
            initiateEditor();
        }
    }, [initiateEditor]);
    // Render
    return (jsx_runtime_1.jsxs("div", __assign({ ref: ref, onClick: handleClick, className: clsx_1.default(classes.root, (_a = {},
            _a[classes.disabled] = disabled,
            _a[classes.error] = error,
            _a[classes.fullWidth] = fullWidth,
            _a[classes.focused] = fcs.focused,
            _a[classes.formControl] = formControl,
            _a[classes.marginDense] = fcs.margin === 'dense',
            _a)) }, { children: [jsx_runtime_1.jsx("div", { className: clsx_1.default(classes.input, (_b = {},
                    _b[classes.disabled] = fcs.disabled,
                    _b[classes.inputMarginDense] = fcs.margin === 'dense',
                    _b[classes.inputHiddenLabel] = fcs.hiddenLabel,
                    _b)), ref: editorElementRef }, void 0),
            options.toolbar && jsx_runtime_1.jsx(RichInputToolbar_1.default, { ref: toolbarElementRef }, void 0),
            renderSuffix
                ? renderSuffix(__assign({}, fcs))
                : null] }), void 0));
});
// DEFAULT EXPORT
exports.default = exports.stylesInjector(RichInputBase);
//# sourceMappingURL=RichInputBase.js.map